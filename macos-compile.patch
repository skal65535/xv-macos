diff -urN clean/xv-3.10a/bggen.c xv-3.10a/bggen.c
--- clean/xv-3.10a/bggen.c	2026-02-23 23:02:18
+++ xv-3.10a/bggen.c	2026-02-24 08:02:02
@@ -1,3 +1,17 @@
+#if defined(__clang__)
+#pragma clang diagnostic ignored "-Wdeprecated-non-prototype"
+#pragma clang diagnostic ignored "-Wdeprecated-declarations"
+#pragma clang diagnostic ignored "-Wknr-promoted-parameter"
+#pragma clang diagnostic ignored "-Wnon-literal-null-conversion"
+#pragma clang diagnostic ignored "-Warray-bounds"
+#pragma clang diagnostic ignored "-Wpointer-bool-conversion"
+#pragma clang diagnostic ignored "-Wdangling-else"
+#pragma clang diagnostic ignored "-Wincompatible-pointer-types-discards-qualifiers"
+#pragma clang diagnostic ignored "-Wformat-security"
+#pragma clang diagnostic ignored "-Wimplicit-int"
+#pragma clang diagnostic ignored "-Wimplicit-function-declaration"
+#pragma clang diagnostic ignored "-Wreturn-type"
+#endif
 /*
  * bggen.c  -  a program that generates backgrounds for use with XV
  *
diff -urN clean/xv-3.10a/vdcomp.c xv-3.10a/vdcomp.c
--- clean/xv-3.10a/vdcomp.c	2026-02-23 23:02:18
+++ xv-3.10a/vdcomp.c	2026-02-24 08:02:02
@@ -1,3 +1,17 @@
+#if defined(__clang__)
+#pragma clang diagnostic ignored "-Wdeprecated-non-prototype"
+#pragma clang diagnostic ignored "-Wdeprecated-declarations"
+#pragma clang diagnostic ignored "-Wknr-promoted-parameter"
+#pragma clang diagnostic ignored "-Wnon-literal-null-conversion"
+#pragma clang diagnostic ignored "-Warray-bounds"
+#pragma clang diagnostic ignored "-Wpointer-bool-conversion"
+#pragma clang diagnostic ignored "-Wdangling-else"
+#pragma clang diagnostic ignored "-Wincompatible-pointer-types-discards-qualifiers"
+#pragma clang diagnostic ignored "-Wformat-security"
+#pragma clang diagnostic ignored "-Wimplicit-int"
+#pragma clang diagnostic ignored "-Wimplicit-function-declaration"
+#pragma clang diagnostic ignored "-Wreturn-type"
+#endif
 /********************************************************************/
 /*  Image Decompression Program - C Version for PC, VAX, Unix       */
 /*  and Macintosh systems.                                          */
@@ -124,7 +138,7 @@
 #    if defined(hp300) || defined(hp800) || defined(NeXT)
 #      include <sys/malloc.h>    /* it's in "sys" on HPs and NeXT */
 #    else
-#      include <malloc.h>        /* FIXME: should explicitly list systems that NEED this, not everyone that doesn't */
+
 #    endif
 
 #  endif /* !most modern systems */
diff -urN clean/xv-3.10a/xcmap.c xv-3.10a/xcmap.c
--- clean/xv-3.10a/xcmap.c	2026-02-23 23:02:18
+++ xv-3.10a/xcmap.c	2026-02-24 08:02:02
@@ -1,3 +1,17 @@
+#if defined(__clang__)
+#pragma clang diagnostic ignored "-Wdeprecated-non-prototype"
+#pragma clang diagnostic ignored "-Wdeprecated-declarations"
+#pragma clang diagnostic ignored "-Wknr-promoted-parameter"
+#pragma clang diagnostic ignored "-Wnon-literal-null-conversion"
+#pragma clang diagnostic ignored "-Warray-bounds"
+#pragma clang diagnostic ignored "-Wpointer-bool-conversion"
+#pragma clang diagnostic ignored "-Wdangling-else"
+#pragma clang diagnostic ignored "-Wincompatible-pointer-types-discards-qualifiers"
+#pragma clang diagnostic ignored "-Wformat-security"
+#pragma clang diagnostic ignored "-Wimplicit-int"
+#pragma clang diagnostic ignored "-Wimplicit-function-declaration"
+#pragma clang diagnostic ignored "-Wreturn-type"
+#endif
 /*
  * xcmap.c - shows the contents of the colormap on 4, 6, or 8-bit X11 displays
  *
diff -urN clean/xv-3.10a/xv.h xv-3.10a/xv.h
--- clean/xv-3.10a/xv.h	2026-02-23 23:03:18
+++ xv-3.10a/xv.h	2026-02-24 08:02:02
@@ -1,3 +1,17 @@
+#if defined(__clang__)
+#pragma clang diagnostic ignored "-Wdeprecated-non-prototype"
+#pragma clang diagnostic ignored "-Wdeprecated-declarations"
+#pragma clang diagnostic ignored "-Wknr-promoted-parameter"
+#pragma clang diagnostic ignored "-Wnon-literal-null-conversion"
+#pragma clang diagnostic ignored "-Warray-bounds"
+#pragma clang diagnostic ignored "-Wpointer-bool-conversion"
+#pragma clang diagnostic ignored "-Wdangling-else"
+#pragma clang diagnostic ignored "-Wincompatible-pointer-types-discards-qualifiers"
+#pragma clang diagnostic ignored "-Wformat-security"
+#pragma clang diagnostic ignored "-Wimplicit-int"
+#pragma clang diagnostic ignored "-Wimplicit-function-declaration"
+#pragma clang diagnostic ignored "-Wreturn-type"
+#endif
 /*
  *  xv.h  -  header file for xv, but you probably guessed as much
  *
@@ -162,7 +176,7 @@
 #  ifndef __NetBSD__
 #    if !(defined __GLIBC__ && __GLIBC__ >= 2)
        extern int   errno;         /* SHOULD be in errno.h, but often isn't */
-       extern char *sys_errlist[]; /* this too... */
+       
 #    endif
 #  endif
 #endif
diff -urN clean/xv-3.10a/xvalg.c xv-3.10a/xvalg.c
--- clean/xv-3.10a/xvalg.c	2026-02-23 23:02:18
+++ xv-3.10a/xvalg.c	2026-02-24 08:02:44
@@ -1419,8 +1419,7 @@
 
 	minx = x - d;	if (minx < selx)       minx = selx;
 	maxx = x + d;	if (maxx >= selx+selw) maxx = selx+selw-1;
-	x1 = minx + abs(random()) % ((maxx - minx) + 1);
-
+	        x1 = minx + labs(random()) % ((maxx - minx) + 1);
 	miny = y - d;	if (miny < sely)       miny = sely;
 	maxy = y + d;	if (maxy >= sely+selh) maxy = sely+selh-1;
 
@@ -1428,20 +1427,17 @@
 	if (y - miny > rdist) miny = (y-rdist);
 	if (maxy - y > rdist) maxy = (y+rdist);
 
-	y1 = miny + abs(random()) % ((maxy - miny) + 1);
-      }
+	        y1 = miny + labs(random()) % ((maxy - miny) + 1);      }
 
       else {
 	/* compute a neighbor within +/-pixX by +/-pixY, cropped to sel */
 
 	minx = x - pixX;  if (minx < selx)       minx = selx;
 	maxx = x + pixX;  if (maxx >= selx+selw) maxx = selx+selw-1;
-	x1 = minx + abs(random()) % ((maxx - minx) + 1);
-
+	        x1 = minx + labs(random()) % ((maxx - minx) + 1);
 	miny = y - pixY;  if (miny < sely)       miny = sely;
 	maxy = y + pixY;  if (maxy >= sely+selh) maxy = sely+selh-1;
-	y1 = miny + abs(random()) % ((maxy - miny) + 1);
-      }
+	        y1 = miny + labs(random()) % ((maxy - miny) + 1);      }
 
       if (PTINRECT(x1,y1, selx,sely,selw,selh)) {  /* should always be true */
 	dp = results + (y1 * w + x1) * 3;
diff -urN clean/xv-3.10a/xvjp2k.c xv-3.10a/xvjp2k.c
--- clean/xv-3.10a/xvjp2k.c	2007-05-14 03:04:37
+++ xv-3.10a/xvjp2k.c	2026-02-24 07:50:03
@@ -73,10 +73,8 @@
    because of the way the former is currently packaged in JasPer Library Version
    1.701, we must override everything else packaged in the "jas_debug.o" module
    with it, otherwise we get "duplicate definition" messages from the linker.
+   [GRR 2024: Modern libjasper defines these in headers or libraries directly, causing conflicts if stubbed here.]
 */
-int jas_getdbglevel(void) {return 0;}
-int jas_setdbglevel(int n) {return 0;}
-int jas_memdump(FILE *fp,void *data,size_t len) {return 0;}
 
 int jas_eprintf(const char *fmt,...)         /* Handle JasPer Library message */
 {
@@ -209,7 +207,7 @@
     So, mark the stream buffer proactively:
  */
     str->bufmode_ |= JAS_STREAM_RDBUF; /* We will only read the stream buffer */
-    if (!(img = jpc_decode(str,0))) goto L2;
+    if (!(img = jas_image_decode(str, jas_image_strtofmt("jpc"), 0))) goto L2;
     if ((vstride = jas_image_numcmpts(img))) /* num. color planes */
       {
 
@@ -399,7 +397,7 @@
     So, mark the stream buffer proactively:
  */
     str->bufmode_ |= JAS_STREAM_RDBUF; /* We will only read the stream buffer */
-    if (!(img = jp2_decode(str,0))) goto L2;
+    if (!(img = jas_image_decode(str, jas_image_strtofmt("jp2"), 0))) goto L2;
     if ((vstride = jas_image_numcmpts(img))) /* num. color planes */
       {
 
@@ -970,7 +968,8 @@
           }
         while (++i <= 2);
       };
-    if (   (*(format == F_JPC ? jpc_encode : jp2_encode))(img,str,options) >= 0
+    int fmt_id = (format == F_JPC) ? jas_image_strtofmt("jpc") : jas_image_strtofmt("jp2");
+    if ( jas_image_encode(img,str,fmt_id,options) >= 0
         && jas_stream_flush(str) >= 0
        ) error = 0; /* Success! */
 L1: jas_image_destroy(img);
diff -urN clean/xv-3.10a/xvpng.c xv-3.10a/xvpng.c
--- clean/xv-3.10a/xvpng.c	2007-05-14 02:53:28
+++ xv-3.10a/xvpng.c	2026-02-24 07:50:03
@@ -32,6 +32,8 @@
 #ifdef HAVE_PNG
 
 #include "png.h"
+#include <zlib.h>
+#include <zlib.h>
 
 /*** Stuff for PNG Dialog box ***/
 #define PWIDE 318
@@ -41,7 +43,7 @@
 #define COMPRESSION   6     /* default zlib compression level, not max
                                (Z_BEST_COMPRESSION) */
 
-#define HAVE_tRNS  (info_ptr->valid & PNG_INFO_tRNS)
+#define HAVE_tRNS  (png_get_valid(png_ptr, info_ptr, PNG_INFO_tRNS))
 
 #define DWIDE    86
 #define DHIGH    104
@@ -99,14 +101,14 @@
    /* fread() returns 0 on error, so it is OK to store this in a png_size_t
     * instead of an int, which is what fread() actually returns.
     */
-   if (fread(data,1,length,(FILE *)png_ptr->io_ptr) != length)
+   if (fread(data,1,length,(FILE *)png_get_io_ptr(png_ptr)) != length)
      png_error(png_ptr, "Read Error");
 }
 
 static void
 png_default_write_data(png_structp png_ptr, png_bytep data, png_size_t length)
 {
-   if (fwrite(data, 1, length, (FILE *)png_ptr->io_ptr) != length)
+   if (fwrite(data, 1, length, (FILE *)png_get_io_ptr(png_ptr)) != length)
      png_error(png_ptr, "Write Error");
 }
 #endif /* PNG_NO_STDIO */
@@ -458,7 +460,7 @@
     FatalError(software);
   }
 
-  if (setjmp(png_ptr->jmpbuf)) {
+  if (setjmp(png_jmpbuf(png_ptr))) {
     png_destroy_write_struct(&png_ptr, &info_ptr);
     return -1;
   }
@@ -489,8 +491,7 @@
     png_set_filter(png_ptr, 0, filter);
   }
 
-  info_ptr->width = w;
-  info_ptr->height = h;
+  /* IHDR handled later */
   if (w <= 0 || h <= 0) {
     SetISTR(ISTR_WARNING, "%s:  image dimensions out of range (%dx%d)",
       fbasename, w, h);
@@ -498,7 +499,7 @@
     return -1;
   }
 
-  info_ptr->interlace_type = interCB.val ? 1 : 0;
+  
 
   linesize = 0;   /* quiet a compiler warning */
 
@@ -542,40 +543,35 @@
         png_destroy_write_struct(&png_ptr, &info_ptr);
         return -1;
       }
-      info_ptr->color_type = PNG_COLOR_TYPE_RGB;
-      info_ptr->bit_depth = 8;
+      png_set_IHDR(png_ptr, info_ptr, w, h, 8, PNG_COLOR_TYPE_RGB, interCB.val ? PNG_INTERLACE_ADAM7 : PNG_INTERLACE_NONE, PNG_COMPRESSION_TYPE_DEFAULT, PNG_FILTER_TYPE_DEFAULT);
     } else /* ptype == PIC8 */ {
       linesize = w;
-      info_ptr->color_type = PNG_COLOR_TYPE_PALETTE;
+      int bit_depth;
       if (numuniqcols <= 2)
-        info_ptr->bit_depth = 1;
+        /* bit_depth = 1; handled by IHDR */
+      if (numuniqcols <= 2) bit_depth = 1; else if (numuniqcols <= 4)
+        bit_depth = 2;
+      else if (numuniqcols <= 16)
+        bit_depth = 4;
       else
-      if (numuniqcols <= 4)
-        info_ptr->bit_depth = 2;
-      else
-      if (numuniqcols <= 16)
-        info_ptr->bit_depth = 4;
-      else
-        info_ptr->bit_depth = 8;
-
+        /* bit_depth = 8; handled by IHDR */
+      png_set_IHDR(png_ptr, info_ptr, w, h, bit_depth, PNG_COLOR_TYPE_PALETTE, interCB.val ? PNG_INTERLACE_ADAM7 : PNG_INTERLACE_NONE, PNG_COMPRESSION_TYPE_DEFAULT, PNG_FILTER_TYPE_DEFAULT);
       for (i = 0; i < numuniqcols; i++) {
         palette[i].red   = r1[i];
         palette[i].green = g1[i];
         palette[i].blue  = b1[i];
       }
-      info_ptr->num_palette = numuniqcols;
-      info_ptr->palette = palette;
-      info_ptr->valid |= PNG_INFO_PLTE;
+      png_set_PLTE(png_ptr, info_ptr, palette, numuniqcols);
     }
   }
 
   else if (colorType == F_GREYSCALE || colorType == F_BWDITHER) {
-    info_ptr->color_type = PNG_COLOR_TYPE_GRAY;
+    /* IHDR handled later */
     if (colorType == F_BWDITHER) {
       /* shouldn't happen */
       if (ptype == PIC24) FatalError("PIC24 and B/W Stipple in WritePNG()");
 
-      info_ptr->bit_depth = 1;
+      /* bit_depth = 1; handled by IHDR */
       if (MONO(r1[0], g1[0], b1[0]) > MONO(r1[1], g1[1], b1[1])) {
         remap[0] = 1;
         remap[1] = 0;
@@ -595,10 +591,11 @@
           png_destroy_write_struct(&png_ptr, &info_ptr);
           return -1;
         }
-        info_ptr->bit_depth = 8;
+        /* bit_depth = 8; handled by IHDR */
       }
       else /* ptype == PIC8 */ {
         int low_precision;
+        int bit_depth = 8;
 
         linesize = w;
 
@@ -617,7 +614,7 @@
         for (; i < 256; i++)
           remap[i]=0;  /* shouldn't be necessary, but... */
 
-        info_ptr->bit_depth = 8;
+        /* bit_depth = 8; handled by IHDR */
 
         /* Note that this fails most of the time because of gamma */
            /* (and that would be a bug:  GRR FIXME) */
@@ -636,7 +633,7 @@
           for (i = 0; i < numuniqcols; i++) {
             remap[i] &= 0xf;
           }
-          info_ptr->bit_depth = 4;
+          bit_depth = 4;
 
           /* try to adjust to 2-bit precision grayscale */
 
@@ -652,7 +649,7 @@
           for (i = 0; i < numuniqcols; i++) {
             remap[i] &= 3;
           }
-          info_ptr->bit_depth = 2;
+          bit_depth = 2;
 
           /* try to adjust to 1-bit precision grayscale */
 
@@ -668,7 +665,7 @@
           for (i = 0; i < numuniqcols; i++) {
             remap[i] &= 1;
           }
-          info_ptr->bit_depth = 1;
+          /* bit_depth = 1; handled by IHDR */
         }
       }
     }
@@ -685,20 +682,19 @@
     text->text = software;
     text->text_length = strlen(text->text);
 
-    info_ptr->max_text = 1;
-    info_ptr->num_text = 1;
-    info_ptr->text = text;
+    png_set_text(png_ptr, info_ptr, text, 1);
   }
 
   Display_Gamma = gDial.val;  /* Save the current gamma for loading */
 
 // GRR FIXME:  add .Xdefaults option to omit writing gamma (size, cumulative errors when editing)--alternatively, modify save box to include "omit" checkbox
-  info_ptr->gamma = 1.0/gDial.val;
-  info_ptr->valid |= PNG_INFO_gAMA;
+  png_set_gAMA(png_ptr, info_ptr, 1.0/gDial.val);
 
   png_write_info(png_ptr, info_ptr);
 
-  if (info_ptr->bit_depth < 8)
+  png_uint_32 w_ihdr, h_ihdr; int bd_ihdr, ct_ihdr;
+  png_get_IHDR(png_ptr, info_ptr, &w_ihdr, &h_ihdr, &bd_ihdr, &ct_ihdr, NULL, NULL, NULL);
+  if (bd_ihdr < 8)
     png_set_packing(png_ptr);
 
   pass=png_set_interlace_handling(png_ptr);
@@ -711,13 +707,13 @@
     int j;
     p = pic;
     for (j = 0; j < h; ++j) {
-      if (info_ptr->color_type == PNG_COLOR_TYPE_GRAY) {
+      if (ct_ihdr == PNG_COLOR_TYPE_GRAY) {
         int k;
         for (k = 0; k < w; ++k)
           png_line[k] = ptype==PIC24 ? MONO(p[k*3], p[k*3+1], p[k*3+2]) :
                                        remap[pc2nc[p[k]]];
         png_write_row(png_ptr, png_line);
-      } else if (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE) {
+      } else if (ct_ihdr == PNG_COLOR_TYPE_PALETTE) {
         int k;
         for (k = 0; k < w; ++k)
           png_line[k] = pc2nc[p[k]];
@@ -742,30 +738,28 @@
 
       strcpy(savecmnt, picComments);
       key = savecmnt;
-      tp = text;
-      info_ptr->num_text = 0;
+      int num_text = 0; int max_text = 1;
 
       comment = strchr(key, ':');
 
       do  {
         /* Allocate a larger structure for comments if necessary */
-        if (info_ptr->num_text >= info_ptr->max_text)
+        if (num_text >= max_text)
         {
           if ((tp =
-              realloc(text, (info_ptr->num_text + 2)*sizeof(png_text))) == NULL)
+              realloc(text, (num_text + 2)*sizeof(png_text))) == NULL)
           {
             break;
           }
           else
           {
-            text = tp;
-            tp = &text[info_ptr->num_text];
-            info_ptr->max_text += 2;
+            max_text += 2;
           }
         }
 
         /* See if it looks like a PNG keyword from LoadPNG */
         /* GRR: should test for strictly < 80, right? (key = 1-79 chars only) */
+        tp = &text[num_text];
         if (comment && comment[1] == ':' && comment - key <= 80) {
           *(comment++) = '\0';
           *(comment++) = '\0';
@@ -810,8 +804,7 @@
             }
 
             tp->compression = tp->text_length > 640 ? 0 : -1;
-            info_ptr->num_text++;
-            tp++;
+            num_text++;
           }
         }
         /* Just a generic comment:  make sure line-endings are valid for PNG */
@@ -834,19 +827,17 @@
           tp->text = key;
           tp->text_length = q - key;
           tp->compression = tp->text_length > 750 ? 0 : -1;
-          info_ptr->num_text++;
+          num_text++;
           key = NULL;
         }
       } while (key && *key);
+      png_set_text(png_ptr, info_ptr, text, num_text);
     }
-    else {
-      info_ptr->num_text = 0;
-    }
   }
-  info_ptr->text = text;
 
-  png_convert_from_time_t(&(info_ptr->mod_time), time(NULL));
-  info_ptr->valid |= PNG_INFO_tIME;
+  png_time mod_time;
+  png_convert_from_time_t(&mod_time, time(NULL));
+  png_set_tIME(png_ptr, info_ptr, &mod_time);
 
   png_write_end(png_ptr, info_ptr);
   fflush(fp);   /* just in case we core-dump before finishing... */
@@ -854,7 +845,7 @@
   if (text) {
     free(text);
     /* must do this or png_destroy_write_struct() 0.97+ will free text again: */
-    info_ptr->text = (png_textp)NULL;
+    
     if (savecmnt)
     {
       free(savecmnt);
@@ -921,7 +912,7 @@
     FatalError("malloc failure in LoadPNG");
   }
 
-  if (setjmp(png_ptr->jmpbuf)) {
+  if (setjmp(png_jmpbuf(png_ptr))) {
     fclose(fp);
     png_destroy_read_struct(&png_ptr, &info_ptr, (png_infopp)NULL);
     if (!read_anything) {
@@ -945,8 +936,10 @@
 #endif
   png_read_info(png_ptr, info_ptr);
 
-  pinfo->w = pinfo->normw = info_ptr->width;
-  pinfo->h = pinfo->normh = info_ptr->height;
+  png_uint_32 w_ihdr; png_uint_32 h_ihdr; int bd_ihdr; int ct_ihdr; int interlace_ihdr;
+  png_get_IHDR(png_ptr, info_ptr, &w_ihdr, &h_ihdr, &bd_ihdr, &ct_ihdr, &interlace_ihdr, NULL, NULL);
+  pinfo->w = pinfo->normw = w_ihdr;
+  pinfo->h = pinfo->normh = h_ihdr;
   if (pinfo->w <= 0 || pinfo->h <= 0) {
     SetISTR(ISTR_WARNING, "%s:  image dimensions out of range (%dx%d)",
       fbasename, pinfo->w, pinfo->h);
@@ -957,9 +950,9 @@
   pinfo->frmType = F_PNG;
 
   sprintf(pinfo->fullInfo, "PNG, %d bit ",
-          info_ptr->bit_depth * info_ptr->channels);
+          bd_ihdr * png_get_channels(png_ptr, info_ptr));
 
-  switch(info_ptr->color_type) {
+  switch(ct_ihdr) {
     case PNG_COLOR_TYPE_PALETTE:
       strcat(pinfo->fullInfo, "palette color");
       break;
@@ -983,15 +976,16 @@
 
   sprintf(pinfo->fullInfo + strlen(pinfo->fullInfo),
 	  ", %sinterlaced. (%d bytes)",
-	  info_ptr->interlace_type ? "" : "non-", filesize);
+	  interlace_ihdr ? "" : "non-", filesize);
 
-  sprintf(pinfo->shrtInfo, "%lux%lu PNG", info_ptr->width, info_ptr->height);
+  sprintf(pinfo->shrtInfo, "%ux%u PNG", (unsigned int)w_ihdr, (unsigned int)h_ihdr);
 
-  if (info_ptr->bit_depth < 8)
+  if (bd_ihdr < 8)
       png_set_packing(png_ptr);
 
-  if (info_ptr->valid & PNG_INFO_gAMA)
-    png_set_gamma(png_ptr, Display_Gamma, info_ptr->gamma);
+  double gamma;
+  if (png_get_gAMA(png_ptr, info_ptr, &gamma))
+    png_set_gamma(png_ptr, Display_Gamma, gamma);
 /*
  *else
  *  png_set_gamma(png_ptr, Display_Gamma, 0.45);
@@ -1000,7 +994,7 @@
   gray_to_rgb = 0;   /* quiet a compiler warning */
 
   if (have_imagebg) {
-    if (info_ptr->bit_depth == 16) {
+    if (bd_ihdr == 16) {
       my_background.red   = imagebgR;
       my_background.green = imagebgG;
       my_background.blue  = imagebgB;
@@ -1013,8 +1007,8 @@
     }
     png_set_background(png_ptr, &my_background, PNG_BACKGROUND_GAMMA_SCREEN,
                        0, Display_Gamma);
-    if ((info_ptr->color_type == PNG_COLOR_TYPE_GRAY_ALPHA ||
-         (info_ptr->color_type == PNG_COLOR_TYPE_GRAY && HAVE_tRNS)) &&
+    if ((ct_ihdr == PNG_COLOR_TYPE_GRAY_ALPHA ||
+         (ct_ihdr == PNG_COLOR_TYPE_GRAY && HAVE_tRNS)) &&
         (imagebgR != imagebgG || imagebgR != imagebgB))  /* i.e., colored bg */
     {
       png_set_gray_to_rgb(png_ptr);
@@ -1022,8 +1016,9 @@
       gray_to_rgb = 1;
     }
   } else {
-    if (info_ptr->valid & PNG_INFO_bKGD) {
-      png_set_background(png_ptr, &info_ptr->background,
+    png_color_16p background;
+    if (png_get_bKGD(png_ptr, info_ptr, &background)) {
+      png_set_background(png_ptr, background,
                          PNG_BACKGROUND_GAMMA_FILE, 1, 1.0);
     } else {
       my_background.red = my_background.green = my_background.blue =
@@ -1033,13 +1028,13 @@
     }
   }
 
-  if (info_ptr->bit_depth == 16)
+  if (bd_ihdr == 16)
     png_set_strip_16(png_ptr);
 
-  if (info_ptr->color_type == PNG_COLOR_TYPE_GRAY ||
-      info_ptr->color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
+  if (ct_ihdr == PNG_COLOR_TYPE_GRAY ||
+      ct_ihdr == PNG_COLOR_TYPE_GRAY_ALPHA)
   {
-    if (info_ptr->bit_depth == 1)
+    if (bd_ihdr == 1)
       pinfo->colType = F_BWDITHER;
     else
       pinfo->colType = F_GREYSCALE;
@@ -1049,9 +1044,10 @@
   pass=png_set_interlace_handling(png_ptr);
 
   png_read_update_info(png_ptr, info_ptr);
+  png_get_IHDR(png_ptr, info_ptr, &w_ihdr, &h_ihdr, &bd_ihdr, &ct_ihdr, &interlace_ihdr, NULL, NULL);
 
-  if (info_ptr->color_type == PNG_COLOR_TYPE_RGB ||
-     info_ptr->color_type == PNG_COLOR_TYPE_RGB_ALPHA || gray_to_rgb)
+  if (ct_ihdr == PNG_COLOR_TYPE_RGB ||
+     ct_ihdr == PNG_COLOR_TYPE_RGB_ALPHA || gray_to_rgb)
   {
     linesize = 3 * pinfo->w;
     if (linesize/3 < pinfo->w) {   /* know pinfo->w > 0 (see above) */
@@ -1065,16 +1061,20 @@
   } else {
     linesize = pinfo->w;
     pinfo->type = PIC8;
-    if (info_ptr->color_type == PNG_COLOR_TYPE_GRAY ||
-       info_ptr->color_type == PNG_COLOR_TYPE_GRAY_ALPHA) {
+    if (ct_ihdr == PNG_COLOR_TYPE_GRAY ||
+       ct_ihdr == PNG_COLOR_TYPE_GRAY_ALPHA) {
       for (i = 0; i < 256; i++)
         pinfo->r[i] = pinfo->g[i] = pinfo->b[i] = i;
     } else {
       pinfo->colType = F_FULLCOLOR;
-      for (i = 0; i < info_ptr->num_palette; i++) {
-        pinfo->r[i] = info_ptr->palette[i].red;
-        pinfo->g[i] = info_ptr->palette[i].green;
-        pinfo->b[i] = info_ptr->palette[i].blue;
+      png_colorp palette;
+      int num_palette;
+      if (png_get_PLTE(png_ptr, info_ptr, &palette, &num_palette)) {
+        for (i = 0; i < num_palette; i++) {
+          pinfo->r[i] = palette[i].red;
+          pinfo->g[i] = palette[i].green;
+          pinfo->b[i] = palette[i].blue;
+        }
       }
     }
   }
@@ -1106,22 +1106,20 @@
 
   png_read_end(png_ptr, info_ptr);
 
-  if (info_ptr->num_text > 0) {
+  png_textp text_ptr;
+  int num_text;
+  if (png_get_text(png_ptr, info_ptr, &text_ptr, &num_text) > 0) {
     commentsize = 1;
-
-    for (i = 0; i < info_ptr->num_text; i++)
-      commentsize += strlen(info_ptr->text[i].key) + 1 +
-                     info_ptr->text[i].text_length + 2;
-
+    for (i = 0; i < num_text; i++)
+      commentsize += strlen(text_ptr[i].key) + 1 + text_ptr[i].text_length + 2;
     if ((pinfo->comment = malloc(commentsize)) == NULL) {
-      png_warning(png_ptr,"can't allocate comment string");
-    }
-    else {
+      png_warning(png_ptr,"can\'t allocate comment string");
+    } else {
       pinfo->comment[0] = '\0';
-      for (i = 0; i < info_ptr->num_text; i++) {
-        strcat(pinfo->comment, info_ptr->text[i].key);
+      for (i = 0; i < num_text; i++) {
+        strcat(pinfo->comment, text_ptr[i].key);
         strcat(pinfo->comment, "::");
-        strcat(pinfo->comment, info_ptr->text[i].text);
+        strcat(pinfo->comment, text_ptr[i].text);
         strcat(pinfo->comment, "\n");
       }
     }
@@ -1143,7 +1141,7 @@
 {
   SetISTR(ISTR_WARNING,"%s:  libpng error: %s", fbasename, message);
 
-  longjmp(png_ptr->jmpbuf, 1);
+  longjmp(png_jmpbuf(png_ptr), 1);
 }
 
 
